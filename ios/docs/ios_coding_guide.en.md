# iOS Coding Guide

## Development Language

Use **Swift**

[KMP](https://kotlinlang.org/docs/multiplatform-intro.html) projects export OC xcframework for iOS platform use,
but during the conversion from Kotlin to OC, some common language features may be lost. For example, Kotlin Enum will be converted to OC Class, which is cumbersome to use.

To solve these problems, we introduced the [SKIE](https://skie.touchlab.co/intro) plugin into the KMP project.
It restores support for some of these language features by modifying the xcframework generated by the Kotlin compiler, making the Swift interface generated by KMP more user-friendly, but only supports Swift.

We also embedded some Swift extensions/methods through SKIE to make the Swift interface exported by KMP more usable.

If you are integrating this SDK into an old OC App, it is recommended to bridge and call GWIoT interfaces through Swift. If you are developing a new App, then use Swift directly.

> The KMP exported Swift product is still in the early development stage. When it stabilizes, we will consider directly exporting the Swift framework. If you are interested, you can [learn more](https://kotlinlang.org/docs/whatsnew21.html#basic-support-for-swift-export)

## SDK Documentation and Code Completion

When the following situations occur, it is recommended to directly search for interfaces through the [API Documentation](https://reoqoo.github.io/gwiotapi/api/-g-w-io-t-api/com.gw.gwiotapi/-g-w-io-t/index.html)

1. After Kotlin uses kdoc comments, the generated OC header file will have corresponding comments, but there may be bugs, and some comments may be lost or disordered.
2. When Xcode has not fully indexed the project code, it may not prompt code completion during coding, especially when multiple projects are opened simultaneously.

## Interface Usage Instructions

### GWIoT

In the interface documentation, we see the following `GWIoT` definition, which is a collection of application layer interfaces. All interfaces required for App development are called through `GWIoT`

```kotlin
// kotlin
object GWIoT : IBindComponent, IInitializeComponent, IPluginConfigComponent,
    IListenerWatchComponent, IPluginComponent, IPropComponent, IAlbumComponent, IUserInfoComponent,
    IHttpServiceComponent, IDevMangerComponent, IDevShareComponent, IAccountRegisterComponent,
    IAccountManagerComponent
```

###  

- `object` type, simply understood as a class that Kotlin implements as a singleton by default. iOS directly uses its singleton through `GWIoT.shared`
   Other objects are similar, but only GWIoT is currently needed at the App layer.

- `IBindComponent`, `IInitializeComponent`..., are interfaces implemented by GWIoT, which are Protocols in iOS.

- For each protocol implemented by GWIoT, there is usually a corresponding property that implements this protocol, named `xxxComp`, such as `IBindComponent` ->
   `bindComp`, `IInitializeComponent` -> `initializeComp`, and so on. This is because GWIoT implements many interfaces, resulting in many automatically prompted methods and properties during use, which is inconvenient for developers. These Comp objects are added to group its interfaces.
   The following calling methods are equivalent.

```swift
  GWIoT.shared.accountComp.login(account: account, password: password) { result, error in
    // handle result
  }
  
  GWIoT.shared.login(account: account, password: password) { result, error in
    // handle result
  }
  
  // or use Concurrency
  let result = try await GWIoT.shared.accountComp.login(account: account, password: password)
  
  let result = try await GWIoT.shared.login(account: account, password: password)
```

### Method Call and Result Handling
The example of calling the `login()` method in the previous section is defined in Kotlin as follows:
```kotlin
// kotlin
suspend fun login(account: AccountType, password: String): GWResult<User>
```
`supsend` is a Kotlin coroutine keyword, similar to Swift using the `async` keyword to declare an asynchronous function. The exported swift header file is as follows. The Kotlin `suspend` keyword will be converted to OC's `completionHandler` callback, and its corresponding `async` method is generated when the OC converts the Swift header file.
```swift
// kotlin -> OC -> swift
func login(account: any AccountType, password: String, completionHandler: @escaping (GWResult<User>?, (any Error)?) -> Void)

// swift completionHandler -> async
func login(account: any AccountType, password: String) async throws -> GWResult<User>
```

Both methods can be used normally in Swift, but when processing results, since Kotlin exceptions cannot be caught on iOS platform, we will handle catch exceptions internally and convert them into `GWResult.Failure` returns.
Therefore, the `error` in `completionHandler` is usually empty and does not need to be processed. There is no need for `try catch` when using GWIoT's async throws method. In addition, we provide methods prefixed with `gw_iot` to convert GWResult to Swift's Result for easy use.
The complete example is as follows:
```swift
GWIoT.shared.login(account: AccountTypeEmail(email: "test@example.com"), password: "Testpwd123!") { result, error in
   switch(gwiot_handleCb(result, error)) {
   case .success(let user):
       print("user \(user) login.")
   case .failure(let err):
       print("login failed. \(err.message)")
   }
}

// or use Concurrency
let result = try await GWIoT.shared.login(account: AccountTypeEmail(email: "test@example.com"), password: "Testpwd123!")
switch(gwiot_swiftResult(of: result)) {
case .success(let user):
    print("user \(user) login.")
case .failure(let err):
    print("login failed. \(err.message)")
}
```

### Value Enum
Kotlin does not have value enums, but similar to `sealed class`, but when exported to OC, each value will be converted to OC Class. SKIE has the `onEnum(of:)` method to convert it into an enum form for easy use.
GWResult mentioned above is one example, but for handling GWResult, it is recommended to directly use `gwiot_swiftResult(:)` mentioned above.
```swift
// kotlin
sealed class GWResult<T> {
    class Success<T>(val data: T?) : GWResult<T>() 
    class Failure<T>(val err: GWError?) : GWResult<T>()
}

// swift usage
let result = try await GWIoT.shared.login()...
switch(onEnum(of: result)) {
    case .success(let s): // s is GWResult.Success<User>
    case .failure(let f): // f is GWResult.Failure
}

// Since the onEnum(of:) method only parses the type, and when processing the result, we generally only care about the successful data or failure error, so we added the gwiot_swiftResult method to directly convert it to Swift's Result.
switch(gwiot_swiftResult(of: result)) {
    case.success(let user): 
    case.failure(let error): 
}
```

### Observe
In the interfaces, some properties are observable types.
- `LiveData<T>`, can listen to changes in its value, triggers notification of the current value when listening, and also get the current value through `value`.
- `LiveEvent<T>`, events in the SDK are notified through this type, the difference from LiveData is that it does not notify historical values.

> `LiveData<T>` and `LiveEvent<T>` are similar to CurrentValueSubject and PassthroughSubject in Swift Combine respectively.

```swift
// get current value 
let user = GWIoT.shared.user.value

// observe value change
GWIoT.shared.user.observe(weakRef: self) { newValue in
    // handle newValue
}

// observe forever, will not be released, use it sparingly.
GWIoT.shared.user.observeForever { newValue in
    // handle newValue
}

// observe props changed events
GWIoT.shared.propsChanged.observe(weakRef: self) { event in
    guard let event else { return }
    switch onEnum(of: event) {
    case .onlineStatusChanged(let ev):
        print("onlineStatusChanged deviceId: \(ev.deviceId), isOnline: \(ev.isOnline)")
    case .powerStatusChanged(let ev):
        print("powerStatusChanged deviceId: \(ev.deviceId), powerStatus: \(ev.powerStatus)")
    case .propsUpdated(let ev):
        print("propsUpdated deviceId:\(ev.deviceId), props: \(ev.props)")
    }
}
```

### Other
This only lists some common iOS coding situations, we will continue to supplement when necessary. For others, please refer to the demo. If you have any questions or suggestions, please feel free to contact us at any time.